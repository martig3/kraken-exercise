import { Injectable, Logger } from '@nestjs/common';
import { Octokit } from '@octokit/rest';
import { err, ok, Result } from 'neverthrow';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';

@Injectable()
export class GithubService {
  private readonly logger = new Logger(GithubService.name);
  octokit: Octokit;
  constructor() {
    this.octokit = new Octokit({
      auth: process.env.GITHUB_TOKEN,
    });
  }
  async submitPR(
    repoPath: string,
    filePath: string,
    uuid: string,
  ): Promise<Result<string, string>> {
    const execAsync = promisify(exec);
    const remoteInfo = (
      await execAsync(`cd ${repoPath} && git remote get-url origin`)
    ).stdout;
    const remote = this.parseGitHubRepoInfo(remoteInfo);
    if (!remote) {
      return err('No remote found');
    }

    try {
      const { data: pullRequest } = await this.octokit.pulls.create({
        owner: remote.owner,
        repo: remote.repo,
        title: `Enhanced test coverage for ${filePath}`,
        body: `This pull request enhances the test coverage for ${filePath}.\n\n## Changes\n- Improved test coverage using AI-generated suggestions\n- Updated test file: ${filePath.replace('.ts', '.test.ts')}\n\n## Generated by\nAI-powered test enhancement service`,
        head: `enhance/tests-${uuid}`,
        base: 'main',
      });

      this.logger.log(`Pull request created: ${pullRequest.html_url}`);

      return ok(pullRequest.html_url);
    } catch (error) {
      this.logger.error('Failed to create pull request:', error);
      return err(`Failed to create pull request: ${error}`);
    }
  }
  private parseGitHubRepoInfo(remoteUrl: string) {
    // Handle both HTTPS and SSH URLs
    const patterns = [
      /github\.com[:/]([^/]+)\/([^/.]+)(\.git)?$/,
      /^git@github\.com:([^/]+)\/([^/.]+)(\.git)?$/,
      /^https?:\/\/github\.com\/([^/]+)\/([^/.]+)(\.git)?$/,
    ];

    for (const pattern of patterns) {
      const match = remoteUrl.match(pattern);
      if (match) {
        return {
          owner: match[1],
          repo: match[2],
        };
      }
    }

    return null;
  }
}
